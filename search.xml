<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RepChain运行机制]]></title>
    <url>%2F2017%2F09%2F03%2FRepChain%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[RepChain的组成模块各司其职，对外提供交易的提交、传播、入块和检索。 模块关系图见下图： 详细介绍如下： APIAPI层为第三方应用提供系统Restful接口，接口包括以下功能： 账户的管理与验证 交易构造和签名 检索：包括区块检索、交易检索等 网络传播交易提交到代理节点（通过Protobuf序列化）之后，代理节点在本地预执行交易，如果预执行正常，将交易以Protobuf消息体的格式向全网广播，否则向提交者返回错误信息。交易以gossip协议传播到全网并最终全网一致。交易传播在TLS协议之上进行，因此只有进入信任证书列表的节点才能传播交易。 共识候选人节点不断收集交易，当随机抽签结果，自己成为出块人，立即启动预出块逻辑，即： 确定本区块打包的交易及其顺序； 在本地按顺序验证交易签名，预执行交易，剔除无效交易，将每笔交易执行结果的Merkle根入块； 对预出块签名并向背书节点请求背书； 以上逻辑完成了输入共识。接下来的背书阶段将完成输出共识： 背书节点收到预出块之后，验证出块人资格； 如果出块人有效，在本地按顺序验证交易签名，预执行交易，比较每笔交易本地执行结果的Merkle根与预出块中的结果； 如果执行结果一致，对预出块进行背书签名； 当出块人收集到足够数量的背书，预出块附上背书签名，成为合法的正式区块，并向全网广播。 区块入链节点收到合法的区块之后，在本地进行持久化。持久化包括三方面的内容： 要将区块数据通过文件系统API写入分段文件； 将交易执行的结果持久化到KV数据库； 为区块及交易建立索引并写入KV数据库，以备检索。 区块入链之后，区块链上的任意一个节点都具备对外部API提供检索服务的能力。 上述过程是区块链对等节点之间实现交易提交、传播、入块的主流程。下面两个模块为这个主流程提供基础服务。 合约容器交易的预执行和交易的正式执行都依赖合约容器。合约容器具备以下能力： 安全隔离：能够将非信任的第三方脚本与宿主节点进行安全隔离，避免个别合约存在的性能问题导致宿主节点资源崩溃，无法提供正常服务； 为合约脚本提供上下文及底层API支持； 状态回滚：合约执行会改变WorldState状态，但是当合约执行出现异常，合约容器有能力将WorldState状态回滚到合约执行之前； 合约串行执行与并行执行：对于存在前后依赖的交易，必须串行执行；对于不存在前后依赖的交易，能够并行执行。 合约容器对外提供三项服务： 合约部署：将合约脚本加载到内存，准备执行； 合约预执行：模拟合约执行，在内存中改变WorldState状态，但是并不持久化； 合约执行：执行合约，并持久化WorldState状态。 可视化可视化的目标在于：将复杂的交易提交、传播、共识入块的过程直观化以便于理解；支持过程事件的回放以便于审计和追踪。要实现这个目标，需要做两方面的工作： 在网络层，能够收集过程事件，并将其序列化push到Web端； 在展示层，能够处理过程事件，利用H5图形技术，完成实时状态的图形展示，包括：节点入网／离网的自动布局、交易的发送与接收、背书的发送与接收、出块的发送与接收等，块链的展示等。 下图为图形展示截图：]]></content>
  </entry>
  <entry>
    <title><![CDATA[RepChain系统组成]]></title>
    <url>%2F2017%2F09%2F02%2FRepChain%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[分层介绍RepChain的系统组成，各层所承担的任务，以及层之间的依赖关系。 RepChain的系统分层如下图： 我们从底层到上层对其要点逐一加以介绍： 数据层数据层负责数据格式定义，在此基础上实现数据的交换、验证、存储、读取及检索。 数据定义采用ProtoBuf定义数据格式，ProtoBuf可以生成各种主流语言的数据实体，并提供性能较高的序列化／反序列化。为下一步支持持久化到磁盘或者序列化到网络传输提供了有力支持。 数据加密／验证采用JDK内置的SHA256哈希作为数字摘要实现，采用JDK内置的SHA1withECDSA作为数字签名实现。 数据存储数据存储使用了两种方式的接口： 文件系统API：用于区块数据的存储和读取，支持区块分段存储； LevelDB：一方面用作WorldState的KV数据存取，另一方面为区块数据建立索引，提供高效的检索服务。 网络层网络层采用JDK内置的TLS实现（具体方式是TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256）支持入网许可验证，在此基础上进行去中心化的gossip组网，网络传播支持P2P和Pub／Sub两种方式。网络节点之间的应答内容是数据定义层的Protobuf消息体。 共识层网络层之上，负责共识的模块完成区块的输入共识和输出共识。 输入共识：在身份准入和节点间TLS安全信道的基础上，输入共识采用兼顾实时性和安全性的算法，该算法能够做到：无需节点之间协商，随机抽签出顺位出块人，既照顾到交易的实时性要求，又能在一定程度防止入网节点串通作弊。 输出共识：抽签出的出块人在本地预执行交易，比较交易结果的merkle根，预出块发送给背书节点。背书节点在本地预执行，结果一致则进行背书签名。出块人收集到足够多的背书之后，正式出块。 合约层共识层执行或者预执行交易时，需要依赖合约容器提供交易执行环境。合约容器具备以下功能： 安全隔离：合约容器能够隔离合约脚本的性能问题（对CPU、内存或磁盘的异常消耗），避免造成宿主节点崩溃；但它无法防止合约本身存在的业务功能安全隐患； 能够解释脚本并执行； 为脚本执行提供上下文环境； 为脚本执行提供底层的API访问。 API层API层提供外部接口，允许第三方应用以Restful的形式与系统交互。RepChain在API层集成了Swagger-UI，允许开发者进行在线测试。API层提供以下基本功能： 交易提交：包括两类交易的提交，即部署合约的交易、调用合约的交易，交易由调用者签名之后通过代理节点扩散到全网； 交易检索：允许按交易id在块链中检索交易； 区块检索：允许按区块高度或区块hash检索区块； 链检索：获得链的最新区块高度、当前hash等。 监控层监控层在区块链网络中收集事件和日志，并将其以Protobuf的格式序列化到Web端，以H5图形技术进行可视化实时状态展示和日志回放。]]></content>
  </entry>
  <entry>
    <title><![CDATA[RepChain目标]]></title>
    <url>%2F2017%2F09%2F02%2FRepChain%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[RepChain面向工程实践，是轻量化、模块化、可视化，并易于集成的区块链核心组件。 RepChain命名含义 Re 即Responsive，采用Actor响应式编程，模块化实现； p 即permission，许可，提供身份准入机制，节点之间采用tls安全通信； chain 即区块链。顾名思义：RepChain是采用响应式编程实现的许可链。 许可链多数区块链项目的目标，既不是要建立比特币或者以太坊那样的在全世界范围提供公开接入服务的公开链，也不是要重蹈传统应用的中心化运维思路，而是需要利用区块链的去中心化特性，解决多个对等主体之间信任问题。许可链更加适合此类目标场景。 许可链在身份准入的基础之上建立安全信道，降低共识成本，提高交易实时性和交易通量。 动机对于上述场景，由于以下原因，开源的开放链并帮不上多少忙： 它们代码体量大，例如采用C++的bitcoin 10万行左右，而采用java的Nxt核心代码也超过4万5千行； 它们模块之前耦合度高，难以作为独立模块嵌入其他应用； 目标因此，我们决定开发一款区块链核心组件，它以上述场景为应用目标，具备以下特征： 标准化：尽可能采用经过工程实践验证的标准组件。一方面可以大幅减少代码量，容易为他人改造使用；另一方面它基础功能稳定，能满足工程实施的要求。 模块化：采用Actor模型实现。网络节点之间以消息格式交互，节点内部以状态驱动，从而具备模块替换的可行性。 可视化：区块链系统的共识部分，非专业人士不好理解。可视化的目标是将复杂的交易传播、共识入块的过程直观化，容易理解。]]></content>
  </entry>
</search>