<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[场景一：存在时间证明]]></title>
    <url>%2F2017%2F09%2F05%2F%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9A%E5%AD%98%E5%9C%A8%E6%97%B6%E9%97%B4%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[区块链可以用来证明某个文件在某个特定时间已经存在及其内容。存证过程分两步： 存证 将文件按照某种hash算法获得其hash值; 将获得的hash值写入区块链，获得唯一交易号。 基于以下两点可以完成上述存证： 区块链区块包含前一区块的hash，但区块入链之后，修改其中任何一个局部，将导致链的完整性受到破坏，从而无法验证通过； 修改原始文件的任何一个局部，将导致文件的hash改变。 鉴证鉴证的过程也比较简单，只需要： 拿出原始文件，用同样的hash算法，获得其hash值； 在区块链中根据hash值，或者交易号进行检索，如果检索结果表明：在某一区块中存在写入该hash值的交易，其区块中包含了时间戳信息，即可证明该文件在该时间（时间范围）已经存在，且其内容与要求鉴证的文件完全一致。 由于交易中包含了交易发起者的签名，而证书中可以包含其拥有者的身份信息，例如：姓名、性别、证件类型、证件编号等。 下面介绍在RepChain中如何实现存证： 合约编写RepChain的合约容器为脚本提供了底层API： 123456def setVal(key: Key, value: Any):Unit =&#123; setState(key,serialiseJson(value))&#125; def getVal(key: Key):Any =&#123; deserialiseJson(getState(key))&#125; RepChain的脚本语言支持javaScript，编写用于存证的合约如下： 12345678910111213141516function write(pn,pv)&#123; shim.setVal(pn,pv); print(&quot;setState:&quot;+pn+&quot;:&quot;+pv)&#125;function read(pn)&#123; return shim.getVal(pn);&#125;function put_proof(pn,pv)&#123; //先检查该hash是否已经存在,如果已存在,抛异常 var pv0 = read(pn); if(pv0) throw &quot;[&quot;+pn+&quot;]已存在，当前值[&quot;+pv0+&quot;]&quot; shim.setVal(pn,pv); print(&quot;putProof:&quot;+pn+&quot;:&quot;+pv)&#125; 合约调用首先编写调用代码如下：12write(&apos;1MH9xedPTkWThJUgT8ZYehiGCM7bEZTVGN&apos;,&apos;json content&apos;);read(&apos;1MH9xedPTkWThJUgT8ZYehiGCM7bEZTVGN&apos;); 第一句调用将hash值及其对应的业务内容写入；第二句读取该hash值对应的内容。 有两种方法可以完成合约调用的测试： 利用RepChain提供的ScalaTest； 通过API提交交易：先部署合约，再调用合约。 通过ScalaTest测试合约用scala编写测试用例如下：1234567891011121314151617181920212223242526272829303132333435363738&quot;sandbox&quot; should &quot;deploy functions and call them then&quot; in &#123; val sysName = &quot;1&quot; //建立PeerManager实例是为了调用transactionCreator(需要用到密钥签名)，无他 val pm = system.actorOf(PeerManager.props(true), &quot;pm_1&quot;) //加载合约脚本 val s1 = scala.io.Source.fromFile(&quot;scripts/proof/deploy.js&quot;) val l1 = try s1.mkString finally s1.close() //加载合约调用脚本 val s2 = scala.io.Source.fromFile(&quot;scripts/proof/invoke.js&quot;) val l2 = try s2.mkString finally s2.close() //准备探针以验证调用返回结果 val probe = TestProbe() var sandbox = system.actorOf(TransProcessor.props(&quot;sandbox&quot;, probe.ref)) //生成deploy交易 val t1 = transactionCreator(sysName, rep.protos.peer.Transaction.Type.CHAINCODE_DEPLOY, &quot;&quot;, &quot;&quot;, List(), l1, None) val msg_send1 = new DoTransaction(t1) probe.send(sandbox, msg_send1) val msg_recv1 = probe.expectMsgType[Sandbox.DoTransactionResult](1000.seconds) val ol1 = msg_recv1.ol val ol1str = compactJson(ol1) //生成invoke交易 //获取deploy生成的chainCodeId val cname = t1.payload.get.chaincodeID.get.name val t2 = transactionCreator(sysName, rep.protos.peer.Transaction.Type.CHAINCODE_INVOKE, &quot;&quot;, l2, List(), &quot;&quot;, Option(cname)) val msg_send2 = new DoTransaction(t2) probe.send(sandbox, msg_send2) val msg_recv2 = probe.expectMsgType[Sandbox.DoTransactionResult](1000.seconds) val ol2 = msg_recv2.ol val ol2str = compactJson(ol2) //获得交易返回值 val rv2 = msg_recv2.r.asInstanceOf[JValue] val re2 = rv2.extract[String] //验证结果是否正确 re2 should be(&quot;json content&quot;)&#125; 运行此测试用例，通过则表明合约执行正常。 通过API执行合约RepChain提供了API的Swagger-UI集成，访问：http://localhost:8081/swagger/ 可以打开api在线测试页面。 先编写并提交一个deploy交易： 123456789&#123; &quot;stype&quot;: 1, &quot;idPath&quot;: &quot;&quot;, &quot;iptFunc&quot;: &quot;&quot;, &quot;iptArgs&quot;: [], &quot;timeout&quot;: 0, &quot;secureContext&quot;: &quot;string&quot;, &quot;code&quot;: &quot;function write(pn,pv)&#123; shim.setVal(pn,pv);&#125; function read(pn)&#123; return shim.getVal(pn);&#125; function put_proof(pn,pv)&#123;var pv0=read(pn); if(pv0) throw &apos;[&apos;+pn+&apos;]已存在，当前值[&apos;+pv0+&apos;]&apos;; shim.setVal(pn,pv); print(&apos;putProof:&apos;+pn+&apos;:&apos;+pv);&#125;&quot;&#125; 提交之后，返回结果如下： 其中的result就是后续调用此合约需要的chainCodeId。接下来编写并提交一个存证：12345678910&#123; &quot;stype&quot;: 2, &quot;idPath&quot;: &quot;&quot;, &quot;idName&quot;: &quot;0edfabbf2fd46aab31d19685e9768ffc6e4c16772cf8495a8a9e47659619255c&quot;, &quot;iptFunc&quot;: &quot;put_proof(&apos;1MH9xedPTkWThJUgT8ZYehiGCM7bEZTVGN&apos;,&apos;json content&apos;);read(&apos;1MH9xedPTkWThJUgT8ZYehiGCM7bEZTVGN&apos;);&quot;, &quot;iptArgs&quot;: [], &quot;timeout&quot;: 0, &quot;secureContext&quot;: &quot;string&quot;, &quot;code&quot;: &quot;string&quot;&#125; 执行结果如下： 如果重复执行同一个hash存证，将返回以下结果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[RepChain运行机制]]></title>
    <url>%2F2017%2F09%2F03%2FRepChain%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[RepChain的组成模块各司其职，对外提供交易的提交、传播、入块和检索。 模块关系图见下图： 详细介绍如下： APIAPI层为第三方应用提供系统Restful接口，接口包括以下功能： 账户的管理与验证 交易构造和签名 检索：包括区块检索、交易检索等 网络传播交易提交到代理节点（通过Protobuf序列化）之后，代理节点在本地预执行交易，如果预执行正常，将交易以Protobuf消息体的格式向全网广播，否则向提交者返回错误信息。交易以gossip协议传播到全网并最终全网一致。交易传播在TLS协议之上进行，因此只有进入信任证书列表的节点才能传播交易。 共识候选人节点不断收集交易，当随机抽签结果，自己成为出块人，立即启动预出块逻辑，即： 确定本区块打包的交易及其顺序； 在本地按顺序验证交易签名，预执行交易，剔除无效交易，将每笔交易执行结果的Merkle根入块； 对预出块签名并向背书节点请求背书； 以上逻辑完成了输入共识。接下来的背书阶段将完成输出共识： 背书节点收到预出块之后，验证出块人资格； 如果出块人有效，在本地按顺序验证交易签名，预执行交易，比较每笔交易本地执行结果的Merkle根与预出块中的结果； 如果执行结果一致，对预出块进行背书签名； 当出块人收集到足够数量的背书，预出块附上背书签名，成为合法的正式区块，并向全网广播。 区块入链节点收到合法的区块之后，在本地进行持久化。持久化包括三方面的内容： 要将区块数据通过文件系统API写入分段文件； 将交易执行的结果持久化到KV数据库； 为区块及交易建立索引并写入KV数据库，以备检索。 区块入链之后，区块链上的任意一个节点都具备对外部API提供检索服务的能力。 上述过程是区块链对等节点之间实现交易提交、传播、入块的主流程。下面两个模块为这个主流程提供基础服务。 合约容器交易的预执行和交易的正式执行都依赖合约容器。合约容器具备以下能力： 安全隔离：能够将非信任的第三方脚本与宿主节点进行安全隔离，避免个别合约存在的性能问题导致宿主节点资源崩溃，无法提供正常服务； 为合约脚本提供上下文及底层API支持； 状态回滚：合约执行会改变WorldState状态，但是当合约执行出现异常，合约容器有能力将WorldState状态回滚到合约执行之前； 合约串行执行与并行执行：对于存在前后依赖的交易，必须串行执行；对于不存在前后依赖的交易，能够并行执行。 合约容器对外提供三项服务： 合约部署：将合约脚本加载到内存，准备执行； 合约预执行：模拟合约执行，在内存中改变WorldState状态，但是并不持久化； 合约执行：执行合约，并持久化WorldState状态。 可视化可视化的目标在于：将复杂的交易提交、传播、共识入块的过程直观化以便于理解；支持过程事件的回放以便于审计和追踪。要实现这个目标，需要做两方面的工作： 在网络层，能够收集过程事件，并将其序列化push到Web端； 在展示层，能够处理过程事件，利用H5图形技术，完成实时状态的图形展示，包括：节点入网／离网的自动布局、交易的发送与接收、背书的发送与接收、出块的发送与接收等，块链的展示等。 下图为图形展示截图：]]></content>
  </entry>
  <entry>
    <title><![CDATA[RepChain系统组成]]></title>
    <url>%2F2017%2F09%2F02%2FRepChain%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[分层介绍RepChain的系统组成，各层所承担的任务，以及层之间的依赖关系。 RepChain的系统分层如下图： 我们从底层到上层对其要点逐一加以介绍： 数据层数据层负责数据格式定义，在此基础上实现数据的交换、验证、存储、读取及检索。 数据定义采用ProtoBuf定义数据格式，ProtoBuf可以生成各种主流语言的数据实体，并提供性能较高的序列化／反序列化。为下一步支持持久化到磁盘或者序列化到网络传输提供了有力支持。 数据加密／验证采用JDK内置的SHA256哈希作为数字摘要实现，采用JDK内置的SHA1withECDSA作为数字签名实现。 数据存储数据存储使用了两种方式的接口： 文件系统API：用于区块数据的存储和读取，支持区块分段存储； LevelDB：一方面用作WorldState的KV数据存取，另一方面为区块数据建立索引，提供高效的检索服务。 网络层网络层采用JDK内置的TLS实现（具体方式是TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256）支持入网许可验证，在此基础上进行去中心化的gossip组网，网络传播支持P2P和Pub／Sub两种方式。网络节点之间的应答内容是数据定义层的Protobuf消息体。 共识层网络层之上，负责共识的模块完成区块的输入共识和输出共识。 输入共识：在身份准入和节点间TLS安全信道的基础上，输入共识采用兼顾实时性和安全性的算法，该算法能够做到：无需节点之间协商，随机抽签出顺位出块人，既照顾到交易的实时性要求，又能在一定程度防止入网节点串通作弊。 输出共识：抽签出的出块人在本地预执行交易，比较交易结果的merkle根，预出块发送给背书节点。背书节点在本地预执行，结果一致则进行背书签名。出块人收集到足够多的背书之后，正式出块。 合约层共识层执行或者预执行交易时，需要依赖合约容器提供交易执行环境。合约容器具备以下功能： 安全隔离：合约容器能够隔离合约脚本的性能问题（对CPU、内存或磁盘的异常消耗），避免造成宿主节点崩溃；但它无法防止合约本身存在的业务功能安全隐患； 能够解释脚本并执行； 为脚本执行提供上下文环境； 为脚本执行提供底层的API访问。 API层API层提供外部接口，允许第三方应用以Restful的形式与系统交互。RepChain在API层集成了Swagger-UI，允许开发者进行在线测试。API层提供以下基本功能： 交易提交：包括两类交易的提交，即部署合约的交易、调用合约的交易，交易由调用者签名之后通过代理节点扩散到全网； 交易检索：允许按交易id在块链中检索交易； 区块检索：允许按区块高度或区块hash检索区块； 链检索：获得链的最新区块高度、当前hash等。 监控层监控层在区块链网络中收集事件和日志，并将其以Protobuf的格式序列化到Web端，以H5图形技术进行可视化实时状态展示和日志回放。]]></content>
  </entry>
  <entry>
    <title><![CDATA[RepChain目标]]></title>
    <url>%2F2017%2F09%2F02%2FRepChain%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[RepChain面向工程实践，是轻量化、模块化、可视化，并易于集成的区块链核心组件。 RepChain命名含义 Re 即Responsive，采用Actor响应式编程，模块化实现； p 即permission，许可，提供身份准入机制，节点之间采用tls安全通信； chain 即区块链。顾名思义：RepChain是采用响应式编程实现的许可链。 许可链多数区块链项目的目标，既不是要建立比特币或者以太坊那样的在全世界范围提供公开接入服务的公开链，也不是要重蹈传统应用的中心化运维思路，而是需要利用区块链的去中心化特性，解决多个对等主体之间信任问题。许可链更加适合此类目标场景。 许可链在身份准入的基础之上建立安全信道，降低共识成本，提高交易实时性和交易通量。 动机对于上述场景，由于以下原因，开源的开放链并帮不上多少忙： 它们代码体量大，例如采用C++的bitcoin 10万行左右，而采用java的Nxt核心代码也超过4万5千行； 它们模块之前耦合度高，难以作为独立模块嵌入其他应用； 目标因此，我们决定开发一款区块链核心组件，它以上述场景为应用目标，具备以下特征： 标准化：尽可能采用经过工程实践验证的标准组件。一方面可以大幅减少代码量，容易为他人改造使用；另一方面它基础功能稳定，能满足工程实施的要求。 模块化：采用Actor模型实现。网络节点之间以消息格式交互，节点内部以状态驱动，从而具备模块替换的可行性。 可视化：区块链系统的共识部分，非专业人士不好理解。可视化的目标是将复杂的交易传播、共识入块的过程直观化，容易理解。]]></content>
  </entry>
</search>