<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[应用场景二：资产管理]]></title>
    <url>%2F2017%2F09%2F05%2F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BA%8C%EF%BC%9A%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7%2F</url>
    <content type="text"><![CDATA[之所以不用数字资产这个词说事儿，是因为查了下维基百科，数字资产已经用来特指数字资源的版权了。 区块链用于资产管理，它维护的是一个账本，这个账本将实体世界的资产和权益进行数字化，通过点对点网络进行登记发行、转让交易、清算交割等金融业务的去中心化网络协议。 在资产管理中，最基本的合约就是资产登记和资产转移，下面分别说明用RepChain中如何实现。 资产登记从前面的章节我们知道：从区块链平台的角度来看，存在两类交易： 部署合约的交易：完成对合约逻辑的部署，但并不执行； 调用合约的交易：调用已经部署好的合约，获得执行结果。 在区块链中，有一个特殊的区块，就是创世区块。区块链虽然运行在去中心化的网络之上，但是节点入网毕竟有先后。设想比特币实验组网的过程，聪大侠的第一个入网节点出块时，并不存在竞争，所以他直接将一句很吊的话甩在创世块里，轻松挣了矿工费。 对于多数资产登记的场景而言，现实世界其实已经将个人的资产份额分配好了，区块链只是拿来记账。比较合理的方式就是：在创世块中直接完成对账户拥有资产份额的登记，作为记账过程的起点。 因此本章节，我们将采用不同于场景一中的方法：不是在普通区块中通过提交交易调用合约，而是在区块链的创世块中调用交易，完成资产登记。 我们不仅要在创世块中部署合约，并且一气呵成在其中调用合约，完成资产登记。为了方便维护，我们用以下的简单思路来完成这个工作： 按RepChain的合约规则编写合约，定义合约文件； 编写对合约的调用，完成资产登记，定义资产登记文件； 写一个创世块工具，读取上述两个文件，生成创世块JSon文件； 网络初始化运行时，组网节点读入创世块JSon文件，生成创世块。 由于区块（包括创世块）的格式是采用protobuf定义的，并且protobuf的工具栈提供了protobuf消息体的json序列化／反序列化，因此我们既可以很容易生成创世块JSon文件，也很容以读取它，生成创世区块。 编写合约12345678910111213function write(pn,pv)&#123; shim.setVal(pn,pv); // print(&quot;setState:&quot;+pn+&quot;:&quot;+pv)&#125;//一次写入多个账户资产,用于资产登记function set(pm)&#123; for(x in pm)&#123; write(x,pm[x]); &#125;&#125;function read(pn)&#123; return shim.getVal(pn);&#125; 编写资产登记脚本为5个账户每人登记了100万。1234567set(&#123; &apos;1MH9xedPTkWThJUgT8ZYehiGCM7bEZTVGN&apos;:1000000, &apos;12kAzqqhuq7xYgm9YTph1b9zmCpZPyUWxf&apos;:1000000, &apos;1GvvHCFZPajq5yVY44n7bdmSfv2MJ5LyLs&apos;:1000000, &apos;1AqZs6vhcLiiTvFxqS5CEqMw6xWuX9xqyi&apos;:1000000, &apos;16SrzMbzdLyGEUKY5FsdE8SVt5tQV1qmBY&apos;:1000000,&#125;); 按照Block的ProtoBuf定义12345678910111213141516171819202122232425message Block &#123; // version - Version used to track any protocol changes. uint32 version = 1; // timestamp - The time at which the block or transaction order was proposed. //This may not be used by all consensus modules. //背书时间 google.protobuf.Timestamp timestamp = 2; // transactions - The ordered list of transactions in the block. repeated Transaction transactions = 3; // stateHash - The state hash after running transactions in this block. // worldstate hash bytes stateHash = 4; // previousBlockHash - The hash of the previous block in the chain. //pre block statehash bytes previousBlockHash = 5; // consensusMetadata - Consensus modules may optionally store any // additional metadata in this field. //用来保存背书的 //bytes consensusMetadata = 6; repeated Endorsement consensusMetadata=6; // nonHashData - Data stored with the block, but not included in the blocks // hash. This allows this data to be different per peer or discarded without // impacting the blockchain. NonHashData nonHashData = 7;&#125; 生成创世块JSon其中背书的签名，由生成工具基于本地密钥对执行。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; &quot;version&quot; : 1, &quot;timestamp&quot; : &quot;2017-05-22T11:07:32.086Z&quot;, &quot;transactions&quot; : [ &#123; &quot;type&quot; : &quot;CHAINCODE_DEPLOY&quot;, &quot;chaincodeID&quot; : &quot;cGF0aDogIiIKbmFtZTogImFlNGY3ZGM4ZDQ0NDhhZjc0N2UxYWRjNzZkMTc0NDgwOWI2YzhiOTZhYTU1NzBhZWZkMDlmNDc4MTU4MDkyYWQiCg==&quot;, &quot;payload&quot; : &#123; &quot;chaincodeID&quot; : &#123; &quot;name&quot; : &quot;ae4f7dc8d4448af747e1adc76d1744809b6c8b96aa5570aefd09f478158092ad&quot; &#125;, &quot;ctorMsg&quot; : &#123; &#125;, &quot;timeout&quot; : 1000, &quot;secureContext&quot; : &quot;secureContext&quot;, &quot;codePackage&quot; : &quot;ZnVuY3Rpb24gbG9hZENlcnQoY2VydCl7CglzaGltLmxvYWRDZXJ0KGNlcnQpOwoJcHJpbnQoImNlcnQ6IitjZXJ0KTsKfQpmdW5jdGlvbiB3cml0ZShwbixwdil7CglzaGltLnNldFZhbChwbixwdik7CgkvLyBwcmludCgic2V0U3RhdGU6IitwbisiOiIrcHYpCn0KZnVuY3Rpb24gc2V0KHBtKXsKCWZvcih4IGluIHBtKXsKCQl3cml0ZSh4LHBtW3hdKTsKCX0KfQpmdW5jdGlvbiByZWFkKHBuKXsKCXJldHVybiBzaGltLmdldFZhbChwbik7Cn0KZnVuY3Rpb24gdHJhbnNmZXIoYWZyb20sYXRvLGFtb3VudCl7CgkvLyBwcmludCgndHhfYWNjb3VudDonK3R4X2FjY291bnQpOwoJaWYoYWZyb20gIT0gdHhfYWNjb3VudCkKCQl0aHJvdyAiWyIrdHhfYWNjb3VudCsiXeaXoOadg+S7jlsiK2Fmcm9tKyJd6L2s5Ye66LWE5LqnIgoJdmFyIHJmcm9tID0gcmVhZChhZnJvbSk7CgkvLyBwcmludChyZnJvbSArICI6IiArIGFtb3VudCkKCWlmKHJmcm9tPGFtb3VudCkKCQl0aHJvdyAi5L2Z6aKd5LiN6LazISIKCXZhciBydG8gPSByZWFkKGF0byk7Cgl3cml0ZShhZnJvbSxyZnJvbS1hbW91bnQpOwoJd3JpdGUoYXRvLHJ0bythbW91bnQpOwoJLy8gcHJpbnQoYXRvKyc6JytyZWFkKGF0bykpCn0=&quot; &#125;, &quot;metadata&quot; : &quot;bWV0YURhdGE=&quot;, &quot;txid&quot; : &quot;ae4f7dc8d4448af747e1adc76d1744809b6c8b96aa5570aefd09f478158092ad&quot;, &quot;timestamp&quot; : &quot;2017-08-10T15:50:19.405Z&quot;, &quot;confidentialityProtocolVersion&quot; : &quot;confidentialityProtocolVersion-1.0&quot;, &quot;nonce&quot; : &quot;bm9uY2U=&quot;, &quot;toValidators&quot; : &quot;dG9WYWxpZGF0b3Jz&quot;, &quot;cert&quot; : &quot;MUpKcDVCekhjN0ZlblZwRTNnWHpGQjl6TTllRWtLZlAxSA==&quot;, &quot;signature&quot; : &quot;MEQCID/l9NL/eUZXXuwRDt/gXl3la0mRVClyLkoetwWBBlMMAiAS1jPmZUN8Xlxu3MEU9DXIw1iYX07JFtzMF3u9lCi9Sw==&quot; &#125;, &#123; &quot;type&quot; : &quot;CHAINCODE_INVOKE&quot;, &quot;chaincodeID&quot; : &quot;cGF0aDogIiIKbmFtZTogImFlNGY3ZGM4ZDQ0NDhhZjc0N2UxYWRjNzZkMTc0NDgwOWI2YzhiOTZhYTU1NzBhZWZkMDlmNDc4MTU4MDkyYWQiCg==&quot;, &quot;payload&quot; : &#123; &quot;chaincodeID&quot; : &#123; &quot;name&quot; : &quot;ae4f7dc8d4448af747e1adc76d1744809b6c8b96aa5570aefd09f478158092ad&quot; &#125;, &quot;ctorMsg&quot; : &#123; &quot;function&quot; : &quot;set(&#123;\n &apos;1MH9xedPTkWThJUgT8ZYehiGCM7bEZTVGN&apos;:1000000,\n &apos;12kAzqqhuq7xYgm9YTph1b9zmCpZPyUWxf&apos;:1000000,\n &apos;1GvvHCFZPajq5yVY44n7bdmSfv2MJ5LyLs&apos;:1000000,\n &apos;1AqZs6vhcLiiTvFxqS5CEqMw6xWuX9xqyi&apos;:1000000,\n &apos;16SrzMbzdLyGEUKY5FsdE8SVt5tQV1qmBY&apos;:1000000,\n&#125;);\n&quot; &#125;, &quot;timeout&quot; : 1000, &quot;secureContext&quot; : &quot;secureContext&quot; &#125;, &quot;metadata&quot; : &quot;bWV0YURhdGE=&quot;, &quot;txid&quot; : &quot;91e283b0-7da0-11e7-91bb-9a39d0c60e00&quot;, &quot;timestamp&quot; : &quot;2017-08-10T15:50:20.363Z&quot;, &quot;confidentialityProtocolVersion&quot; : &quot;confidentialityProtocolVersion-1.0&quot;, &quot;nonce&quot; : &quot;bm9uY2U=&quot;, &quot;toValidators&quot; : &quot;dG9WYWxpZGF0b3Jz&quot;, &quot;cert&quot; : &quot;MUpKcDVCekhjN0ZlblZwRTNnWHpGQjl6TTllRWtLZlAxSA==&quot;, &quot;signature&quot; : &quot;MEUCIQDZI/5xql/3r+CGmXyBZjwn+l88AhEfUmfWo0+i/oJkRQIgSIT/HJ6zFeYMIt3duuOG9qwwduADeMwsH5VUL4QRUgQ=&quot; &#125; ], &quot;consensusMetadata&quot; : [ &#123; &quot;endorser&quot; : &quot;MUpKcDVCekhjN0ZlblZwRTNnWHpGQjl6TTllRWtLZlAxSA==&quot;, &quot;signature&quot; : &quot;MEUCIB+uisTD/3p7I9Gm8duOjj99MH+cwgFCLGNQR4vAzf6rAiEAya/B2kVGnnDr+rmcu/5sHs2ixVBLsaT40lk7QXGaUfU=&quot; &#125;, &#123; &quot;endorser&quot; : &quot;MU1IOXhlZFBUa1dUaEpVZ1Q4WlllaGlHQ003YkVaVFZHTg==&quot;, &quot;signature&quot; : &quot;MEQCIGjjNG3/gGoOEPNF4evLzjRSdZEwVTvIEj1WIaNRiV0XAiBB0uiR57KwABz9QKATfsmf+nvPjGSh0Nws1ndKVsLkNw==&quot; &#125; ]&#125; 资产转移资产转移合约，需要执行两个最基本的检查： 对交易签名者的账户进行检查，只允许操作本人的账户； 对账户余额检查，如果余额小于转出的金额，抛出异常。 编写资产转移的合约如下：12345678910111213function transfer(afrom,ato,amount)&#123; //检查是否从本账户转出资产 if(afrom != tx_account) throw &quot;[&quot;+tx_account+&quot;]无权从[&quot;+afrom+&quot;]转出资产&quot; var rfrom = read(afrom); //检查余额是否足够 if(rfrom&lt;amount) throw &quot;余额不足!&quot; var rto = read(ato); write(afrom,rfrom-amount); write(ato,rto+amount); // print(ato+&apos;:&apos;+read(ato))&#125; 资产转移的合约也可以放在创世块中部署。]]></content>
  </entry>
  <entry>
    <title><![CDATA[应用场景一：存在证明]]></title>
    <url>%2F2017%2F09%2F05%2F%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9A%E5%AD%98%E5%9C%A8%E6%97%B6%E9%97%B4%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[区块链可以用来证明某个文件在某个特定时间已经存在及其内容。存证过程分两步： 存证 将文件按照某种hash算法获得其hash值; 将获得的hash值写入区块链，获得唯一交易号。 基于以下两点可以完成上述存证： 区块链区块包含前一区块的hash，当区块入链之后，修改其中任何一个局部，将导致链的完整性受到破坏，从而无法验证通过； 修改原始文件的任何一个局部，将导致文件的hash改变。 鉴证鉴证的过程也比较简单，只需要： 拿出原始文件，用同样的hash算法，获得其hash值； 在区块链中根据hash值，或者交易号进行检索，如果检索结果表明：在某一区块中存在写入该hash值的交易，其区块中包含了时间戳信息，即可证明该文件在该时间（时间范围）已经存在，且其内容与要求鉴证的文件完全一致。 由于交易中包含了交易发起者的签名，而证书中可以包含其拥有者的身份信息，例如：姓名、性别、证件类型、证件编号等。 下面介绍在RepChain中如何实现存证： 合约编写RepChain的合约容器为脚本提供了底层API： 123456def setVal(key: Key, value: Any):Unit =&#123; setState(key,serialiseJson(value))&#125; def getVal(key: Key):Any =&#123; deserialiseJson(getState(key))&#125; RepChain的脚本语言支持javaScript，编写用于存证的合约如下： 12345678910111213141516function write(pn,pv)&#123; shim.setVal(pn,pv); print(&quot;setState:&quot;+pn+&quot;:&quot;+pv)&#125;function read(pn)&#123; return shim.getVal(pn);&#125;function put_proof(pn,pv)&#123; //先检查该hash是否已经存在,如果已存在,抛异常 var pv0 = read(pn); if(pv0) throw &quot;[&quot;+pn+&quot;]已存在，当前值[&quot;+pv0+&quot;]&quot; shim.setVal(pn,pv); print(&quot;putProof:&quot;+pn+&quot;:&quot;+pv)&#125; 合约调用首先编写调用代码如下：12put_proof(&apos;1MH9xedPTkWThJUgT8ZYehiGCM7bEZTVGN&apos;,&apos;json content&apos;);read(&apos;1MH9xedPTkWThJUgT8ZYehiGCM7bEZTVGN&apos;); 第一句调用将hash值及其对应的业务内容写入；第二句读取该hash值对应的内容。 有两种方法可以完成合约调用的测试： 利用RepChain提供的ScalaTest； 通过API提交交易：先部署合约，再调用合约。 通过ScalaTest测试合约用scala编写测试用例如下：1234567891011121314151617181920212223242526272829303132333435363738&quot;sandbox&quot; should &quot;deploy functions and call them then&quot; in &#123; val sysName = &quot;1&quot; //建立PeerManager实例是为了调用transactionCreator(需要用到密钥签名)，无他 val pm = system.actorOf(PeerManager.props(true), &quot;pm_1&quot;) //加载合约脚本 val s1 = scala.io.Source.fromFile(&quot;scripts/proof/deploy.js&quot;) val l1 = try s1.mkString finally s1.close() //加载合约调用脚本 val s2 = scala.io.Source.fromFile(&quot;scripts/proof/invoke.js&quot;) val l2 = try s2.mkString finally s2.close() //准备探针以验证调用返回结果 val probe = TestProbe() var sandbox = system.actorOf(TransProcessor.props(&quot;sandbox&quot;, probe.ref)) //生成deploy交易 val t1 = transactionCreator(sysName, rep.protos.peer.Transaction.Type.CHAINCODE_DEPLOY, &quot;&quot;, &quot;&quot;, List(), l1, None) val msg_send1 = new DoTransaction(t1) probe.send(sandbox, msg_send1) val msg_recv1 = probe.expectMsgType[Sandbox.DoTransactionResult](1000.seconds) val ol1 = msg_recv1.ol val ol1str = compactJson(ol1) //生成invoke交易 //获取deploy生成的chainCodeId val cname = t1.payload.get.chaincodeID.get.name val t2 = transactionCreator(sysName, rep.protos.peer.Transaction.Type.CHAINCODE_INVOKE, &quot;&quot;, l2, List(), &quot;&quot;, Option(cname)) val msg_send2 = new DoTransaction(t2) probe.send(sandbox, msg_send2) val msg_recv2 = probe.expectMsgType[Sandbox.DoTransactionResult](1000.seconds) val ol2 = msg_recv2.ol val ol2str = compactJson(ol2) //获得交易返回值 val rv2 = msg_recv2.r.asInstanceOf[JValue] val re2 = rv2.extract[String] //验证结果是否正确 re2 should be(&quot;json content&quot;)&#125; 运行此测试用例，通过则表明合约执行正常。 通过API执行合约RepChain提供了API的Swagger-UI集成，访问：http://localhost:8081/swagger/ 可以打开api在线测试页面。 先编写并提交一个deploy交易： 123456789&#123; &quot;stype&quot;: 1, &quot;idPath&quot;: &quot;&quot;, &quot;iptFunc&quot;: &quot;&quot;, &quot;iptArgs&quot;: [], &quot;timeout&quot;: 0, &quot;secureContext&quot;: &quot;string&quot;, &quot;code&quot;: &quot;function write(pn,pv)&#123; shim.setVal(pn,pv);&#125; function read(pn)&#123; return shim.getVal(pn);&#125; function put_proof(pn,pv)&#123;var pv0=read(pn); if(pv0) throw &apos;[&apos;+pn+&apos;]已存在，当前值[&apos;+pv0+&apos;]&apos;; shim.setVal(pn,pv); print(&apos;putProof:&apos;+pn+&apos;:&apos;+pv);&#125;&quot;&#125; 提交之后，返回结果如下： 其中的result就是后续调用此合约需要的chainCodeId。接下来编写并提交一个存证：12345678910&#123; &quot;stype&quot;: 2, &quot;idPath&quot;: &quot;&quot;, &quot;idName&quot;: &quot;0edfabbf2fd46aab31d19685e9768ffc6e4c16772cf8495a8a9e47659619255c&quot;, &quot;iptFunc&quot;: &quot;put_proof(&apos;1MH9xedPTkWThJUgT8ZYehiGCM7bEZTVGN&apos;,&apos;json content&apos;);read(&apos;1MH9xedPTkWThJUgT8ZYehiGCM7bEZTVGN&apos;);&quot;, &quot;iptArgs&quot;: [], &quot;timeout&quot;: 0, &quot;secureContext&quot;: &quot;string&quot;, &quot;code&quot;: &quot;string&quot;&#125; 执行结果如下： 如果重复执行同一个hash存证，将返回以下结果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[RepChain运行机制]]></title>
    <url>%2F2017%2F09%2F03%2FRepChain%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[RepChain的组成模块各司其职，对外提供交易的提交、传播、入块和检索。 模块关系图见下图： 详细介绍如下： APIAPI层为第三方应用提供系统Restful接口，接口包括以下功能： 账户的管理与验证 交易构造和签名 检索：包括区块检索、交易检索等 网络传播交易提交到代理节点（通过Protobuf序列化）之后，代理节点在本地预执行交易，如果预执行正常，将交易以Protobuf消息体的格式向全网广播，否则向提交者返回错误信息。交易以gossip协议传播到全网并最终全网一致。交易传播在TLS协议之上进行，因此只有进入信任证书列表的节点才能传播交易。 共识候选人节点不断收集交易，当随机抽签结果，自己成为出块人，立即启动预出块逻辑，即： 确定本区块打包的交易及其顺序； 在本地按顺序验证交易签名，预执行交易，剔除无效交易，将每笔交易执行结果的Merkle根入块； 对预出块签名并向背书节点请求背书； 以上逻辑完成了输入共识。接下来的背书阶段将完成输出共识： 背书节点收到预出块之后，验证出块人资格； 如果出块人有效，在本地按顺序验证交易签名，预执行交易，比较每笔交易本地执行结果的Merkle根与预出块中的结果； 如果执行结果一致，对预出块进行背书签名； 当出块人收集到足够数量的背书，预出块附上背书签名，成为合法的正式区块，并向全网广播。 区块入链节点收到合法的区块之后，在本地进行持久化。持久化包括三方面的内容： 要将区块数据通过文件系统API写入分段文件； 将交易执行的结果持久化到KV数据库； 为区块及交易建立索引并写入KV数据库，以备检索。 区块入链之后，区块链上的任意一个节点都具备对外部API提供检索服务的能力。 上述过程是区块链对等节点之间实现交易提交、传播、入块的主流程。下面两个模块为这个主流程提供基础服务。 合约容器交易的预执行和交易的正式执行都依赖合约容器。合约容器具备以下能力： 安全隔离：能够将非信任的第三方脚本与宿主节点进行安全隔离，避免个别合约存在的性能问题导致宿主节点资源崩溃，无法提供正常服务； 为合约脚本提供上下文及底层API支持； 状态回滚：合约执行会改变WorldState状态，但是当合约执行出现异常，合约容器有能力将WorldState状态回滚到合约执行之前； 合约串行执行与并行执行：对于存在前后依赖的交易，必须串行执行；对于不存在前后依赖的交易，能够并行执行。 合约容器对外提供三项服务： 合约部署：将合约脚本加载到内存，准备执行； 合约预执行：模拟合约执行，在内存中改变WorldState状态，但是并不持久化； 合约执行：执行合约，并持久化WorldState状态。 可视化可视化的目标在于：将复杂的交易提交、传播、共识入块的过程直观化以便于理解；支持过程事件的回放以便于审计和追踪。要实现这个目标，需要做两方面的工作： 在网络层，能够收集过程事件，并将其序列化push到Web端； 在展示层，能够处理过程事件，利用H5图形技术，完成实时状态的图形展示，包括：节点入网／离网的自动布局、交易的发送与接收、背书的发送与接收、出块的发送与接收等，块链的展示等。 下图为图形展示截图：]]></content>
  </entry>
  <entry>
    <title><![CDATA[RepChain系统组成]]></title>
    <url>%2F2017%2F09%2F02%2FRepChain%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[分层介绍RepChain的系统组成，各层所承担的任务，以及层之间的依赖关系。 RepChain的系统分层如下图： 我们从底层到上层对其要点逐一加以介绍： 数据层数据层负责数据格式定义，在此基础上实现数据的交换、验证、存储、读取及检索。 数据定义采用ProtoBuf定义数据格式，ProtoBuf可以生成各种主流语言的数据实体，并提供性能较高的序列化／反序列化。为下一步支持持久化到磁盘或者序列化到网络传输提供了有力支持。 数据加密／验证采用JDK内置的SHA256哈希作为数字摘要实现，采用JDK内置的SHA1withECDSA作为数字签名实现。 数据存储数据存储使用了两种方式的接口： 文件系统API：用于区块数据的存储和读取，支持区块分段存储； LevelDB：一方面用作WorldState的KV数据存取，另一方面为区块数据建立索引，提供高效的检索服务。 网络层网络层采用JDK内置的TLS实现（具体方式是TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256）支持入网许可验证，在此基础上进行去中心化的gossip组网，网络传播支持P2P和Pub／Sub两种方式。网络节点之间的应答内容是数据定义层的Protobuf消息体。 共识层网络层之上，负责共识的模块完成区块的输入共识和输出共识。 输入共识：在身份准入和节点间TLS安全信道的基础上，输入共识采用兼顾实时性和安全性的算法，该算法能够做到：无需节点之间协商，随机抽签出顺位出块人，既照顾到交易的实时性要求，又能在一定程度防止入网节点串通作弊。 输出共识：抽签出的出块人在本地预执行交易，比较交易结果的merkle根，预出块发送给背书节点。背书节点在本地预执行，结果一致则进行背书签名。出块人收集到足够多的背书之后，正式出块。 合约层共识层执行或者预执行交易时，需要依赖合约容器提供交易执行环境。合约容器具备以下功能： 安全隔离：合约容器能够隔离合约脚本的性能问题（对CPU、内存或磁盘的异常消耗），避免造成宿主节点崩溃；但它无法防止合约本身存在的业务功能安全隐患； 能够解释脚本并执行； 为脚本执行提供上下文环境； 为脚本执行提供底层的API访问。 API层API层提供外部接口，允许第三方应用以Restful的形式与系统交互。RepChain在API层集成了Swagger-UI，允许开发者进行在线测试。API层提供以下基本功能： 交易提交：包括两类交易的提交，即部署合约的交易、调用合约的交易，交易由调用者签名之后通过代理节点扩散到全网； 交易检索：允许按交易id在块链中检索交易； 区块检索：允许按区块高度或区块hash检索区块； 链检索：获得链的最新区块高度、当前hash等。 监控层监控层在区块链网络中收集事件和日志，并将其以Protobuf的格式序列化到Web端，以H5图形技术进行可视化实时状态展示和日志回放。]]></content>
  </entry>
  <entry>
    <title><![CDATA[RepChain目标]]></title>
    <url>%2F2017%2F09%2F02%2FRepChain%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[RepChain面向工程实践，是轻量化、模块化、可视化，并易于集成的区块链核心组件。 RepChain命名含义 Re 即Responsive，采用Actor响应式编程，模块化实现； p 即permission，许可，提供身份准入机制，节点之间采用tls安全通信； chain 即区块链。顾名思义：RepChain是采用响应式编程实现的许可链。 许可链多数区块链项目的目标，既不是要建立比特币或者以太坊那样的在全世界范围提供公开接入服务的公开链，也不是要重蹈传统应用的中心化运维思路，而是需要利用区块链的去中心化特性，解决多个对等主体之间信任问题。许可链更加适合此类目标场景。 许可链在身份准入的基础之上建立安全信道，降低共识成本，提高交易实时性和交易通量。 动机对于上述场景，由于以下原因，开源的开放链并帮不上多少忙： 它们代码体量大，例如采用C++的bitcoin 10万行左右，而采用java的Nxt核心代码也超过4万5千行； 它们模块之前耦合度高，难以作为独立模块嵌入其他应用； 目标因此，我们决定开发一款区块链核心组件，它以上述场景为应用目标，具备以下特征： 标准化：尽可能采用经过工程实践验证的标准组件。一方面可以大幅减少代码量，容易为他人改造使用；另一方面它基础功能稳定，能满足工程实施的要求。 模块化：采用Actor模型实现。网络节点之间以消息格式交互，节点内部以状态驱动，从而具备模块替换的可行性。 可视化：区块链系统的共识部分，非专业人士不好理解。可视化的目标是将复杂的交易传播、共识入块的过程直观化，容易理解。]]></content>
  </entry>
</search>